Hash与信息指纹有什么关系？为什么要用信息指纹？

回忆一下以前使用hash的时候：

```
Java: HashTable<string,int> ht = new HashTable<string,int> ();
 
C++: map<string,int> m;
```

其实平时这样用也无所谓，但是数据量大了，string就不好办了。

hash为什么要用信息指纹？请看下面的例子

任何一段信息文字，都可以对应一个不太长的随机数，作为区别它和其它信息的“指纹”。

在爬虫中网址的消重上，需要在哈希表中纪录已经访问过的网址（URL)。假设现在要存储在哈希表中如果以字符串的形式直接存储网址，既费内存空间，又浪费查找时间。

一方面，现在的网址一般都较长，多的达到一百甚至几百个字符。而哈希表的存储效率一般只有 50%（个人理解：为了避免高碰撞，一般哈希存到一半时都翻倍或采取其他策略），所以很费内存；

另一方面，由于比较费空间，假设存储的URL大概有500M，由于哈希的存储效率，实际就需要1G空间存储，即使把这些网址放到了计算机的内存中，由于网址长度不固定，以字符串的形式查找的效率会很低（个人理解：虽然说哈希的查找效率为O(1)，但是由于字符串长度不固定，在查找某个特定串的时候无法根据偏移量直接找到或者找到也应该比较费劲，如果忽略串的长度不固定，采用统一长度的内存存储每个串，那又太费空间了，所以很麻烦）。

那么怎么办？我们应该想法既让空间节省下来（不直接存储字符串），又能在查找上提高效率？

现假定网址的平均长度为一百个字符，那么存贮 200 亿个网址本身至少需要 2 TB，即两千 GB 的容量，考虑到哈希表的存储效率一般只有 50%，实际需要的内存在 4 TB以上，这么大的空间查找起来也怪不容易的。因此如果我们能够找到一个函数，将这 200 亿个网址随机地映射到128 二进位即 16 个字节的整数空间，这样每个网址只需要占用 16 个字节而不是原来的一百个，这就能把存储网址的内存需求量降低到原来的 1/6。这个16 个字节的随机数，就称做该网址的信息指纹（Fingerprint)

由于指纹是固定的 128 位整数，因此查找的计算量比字符串比较小得多。这种整数的查找比原来字符串查找,可以快几倍到几十倍。

信息指纹的一个特征是其不可逆性, 也就是说,无法根据信息指纹推出原有信息，这种性质，正是网络加密传输所需要的，关于加密，这里不讨论了。

产生信息指纹的关键算法是伪随机数产生器算法（prng)，比较经典的哈希算法有 MD5 和 SHA1 等，它们可以将不定长的信息变成定长的 128 二进位或者 160 二进位随机数。

不要以为信息指纹有多么了不得，如果信息量很大，它还是在空间上承受不住，那就要看布隆过滤器了，详见：[布隆过滤器（Bloom Filter）](https://github.com/fupengfei058/article-collection/)

本文资料整理自[数学之美系列十三：信息指纹](http://www.google.com.hk/ggblog/googlechinablog/2006/08/blog-post_8115.html)
